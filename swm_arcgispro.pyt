# -*- coding: utf-8 -*-import arcpyfrom arcpy.sa import *import timeclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "SWM ArcGIS Pro"        self.description = "This tool has parameters with default values."        self.alias = "swmarcgispro"        # List of tool classes associated with this toolbox        self.tools = [Tool]class Tool(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "SWM ArcPy"        self.description = "Dieses einfache Bodenwasser-Modell berechnet für jede Rasterzelle eines Einzugsgebietes die Boden-Wasser-Bilanz. Ausgabe des Modells ist eine Tabelle mit täglichen Abflussvolumen in m3 s-1 für das Einzugsgebiet, sowie auf Wunsch die berechneten Rasterdatensätze (auch über einen Wunschzeitraum aufsummiert) verschiedener Modellparameter."        self.canRunInBackground = False        # Define default values        self.workspace_default = r'C:\2023_HydroGIS\HYDROGIS_FUER_HANNES\Vogelsberg_GISVogelsberg_GIS.gdb'        self.basin_default = r'C:/2023_HydroGIS/HYDROGIS_FUER_HANNES/Vogelsberg_GIS/Vogelsberg_GIS.gdb/Hydrologie/EZG_Eichelsachsen_Vektor'        self.basinID_default = "Id"        self.s_init_default = r'C:/2023_HydroGIS/HYDROGIS_FUER_HANNES/Vogelsberg_GIS/Vogelsberg_GIS.gdb/FK_von_L'        self.start_default = 20210101        self.end_default = 20210102        self.rp_factor_default = 0.85        self.c_min_default = 150        self.idw_exponent_default = 1.0        self.workspace_default = r'C:\2023_HydroGIS\HYDROGIS_FUER_HANNES\swmouttest'        self.name_default = "Ergebnis"    def getParameterInfo(self):        """Define parameter definitions"""        workspace_param = arcpy.Parameter(            displayName="Geodatenbank der Basisdaten",            name="workspace",            datatype="DEWorkspace",            parameterType="Optional",            direction="Input"        )        basin_param = arcpy.Parameter(            displayName="Einzugsgebiet",            name="basin",            datatype="DEFeatureClass",            parameterType="Optional",            direction="Input"        )        basinID_param = arcpy.Parameter(            displayName="Attributefeldname zur Identifikation des EZG",            name="basinID",            datatype="Field",            parameterType="Optional",            direction="Input"        )        s_init_param = arcpy.Parameter(            displayName="Initialer Bodenwasserspeicher",            name="s_init",            datatype="DERasterDataset",            parameterType="Optional",            direction="Input"        )        start_param = arcpy.Parameter(            displayName="Startdatum (JJJJMMTT)",            name="start",            datatype="Long",            parameterType="Optional",            direction="Input"        )        end_param = arcpy.Parameter(            displayName="Enddatum (JJJJMMTT)",            name="end",            datatype="Long",            parameterType="Optional",            direction="Input"        )        rp_factor_param = arcpy.Parameter(            displayName="Reduktionsfaktor",            name="rp_factor_min",            datatype="Double",            parameterType="Optional",            direction="Input"        )        c_param = arcpy.Parameter(            displayName="c Parameter (Default Value: 150)",            name="c_min",            datatype="GPLong",            parameterType="Optional",            direction="Input"        )        idw_exponent_param = arcpy.Parameter(            displayName="Exponent der IDW-Methode zur Niederschlagsinterpolation",            name="idw_exponent",            datatype="GPDouble",            parameterType="Optional",            direction="Input"        )        workspace_param = arcpy.Parameter(            displayName="Speicherpfad des Ausgabeordners",            name="workspace",            datatype="DEWorkspace",            parameterType="Optional",            direction="Input"        )        name_param = arcpy.Parameter(            displayName="Name des Ausgabeordners",            name="name",            datatype="GPString",            parameterType="Optional",            direction="Input"        )        #workspace_param.filter.list = ["File Geodatabase"]        #workspace_param.workspaceType = "All"        #workspace_param.description = "Select the workspace where the tool will operate."        #default_workspace = r'C:\2023_HydroGIS\HYDROGIS_FUER_HANNES\Vogelsberg_GISVogelsberg_GIS.gdb'        # Check if the default GDB path exists        #if os.path.exists(default_workspace):        #    workspace_param.defaultValue = default_workspace        #else:        #    arcpy.AddWarning(f"Default GDB path does not exist: {default_workspace}")        #basin_param.filter.list = ["Feature Class"]        #basin_param.description = "Einzugsgebiet"        #basin_param.defaultValue = "C:/2023_HydroGIS/HYDROGIS_FUER_HANNES/Vogelsberg_GIS/Vogelsberg_GIS.gdb/Hydrologie/EZG_Eichelsachsen_Vektor"        #basinID_param.parameterDependencies = [basin_param.name]        ##basinID_param.schema.clone = True        # basinID_param.description = "Attributefeldname zur Identifikation des EZG"        #basinID_param.defaultValue = "Id"        ##s_init_param.filter.list = ["RasterDataset"]        #s_init_param.description = "Initialer Bodenwasserspeicher"        #s_init_param.defaultValue = "C:/2023_HydroGIS/HYDROGIS_FUER_HANNES/Vogelsberg_GIS/Vogelsberg_GIS.gdb/FK_von_L"        #start_param.defaultValue = "20210101"        #end_param.defaultValue = "20210102"        #rp_factor_param.defaultValue = "0.85"        workspace_param.default = self.workspace_default        basin_param.default = self.basin_default        basinID_param.default = self.basinID_default        s_init_param.default = self.s_init_default        start_param.default = self.start_default        end_param.default = self.end_default        rp_factor_param.default = self.rp_factor_default        c_param.default = self.c_min_default        idw_exponent_param.default = self.idw_exponent_default        workspace_param.default = self.workspace_default        name_param.default = self.name_default        return [workspace_param, basin_param, basinID_param, s_init_param, start_param, end_param, rp_factor_param,                c_param, idw_exponent_param, workspace_param, name_param]    def validate(self, parameters, messages):        s_init_param = parameters[3].valueAsText        desc = arcpy.Describe(input_raster)        if not desc.dataType == "RasterDataset":            messages.addErrorMessage("Please select a valid raster dataset.")            raise arcpy.ExecuteError    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def get_pet(haude_factor, temperature, humidity, date, parameter_safe):        """        Calculates the potential evapotranspiration (PET) by Haude.        :param haude_factor: Haude-factor of the current month (:type: raster)        :param temperature: temperature of the day in degrees Celsius (:type: float)        :param humidity: relative humidity (:type: float)        :param date: daily ID (:type: integer)        :param parameter_safe: values of the variable combination (:type: tuple)        :return: PET (:type: raster)        """        pet_raster = haude_factor * (6.1 * 10 ** ((7.5 * temperature) / (temperature + 237.2))) * (                    1.0 - humidity / 100.0)        pet_raster.save("PET_rp{}_c{}_{}.tif".format(parameter_safe[0], parameter_safe[1], date))        arcpy.AddMessage(time.strftime("%H:%M:%S: ") + "PET berechnet.")        return pet_raster    def get_aet(pet_raster, water_raster, s_pre_raster, rp_raster, rpwp_dif_raster, wp_raster, date, parameter_safe):        """        Calculates the actual evapotranspiration (AET). The AET equals the value of the PET in water cells and in cells with        a soilwater content above the reduction point. The AET equals zero if the reduction point equals the wilting point.        In the other cases the AET is calculated by the soilwater content, wilting point, difference between wilting point        and reduction point and PET.        :param pet_raster: output of the function "get_pet" (:type: raster)        :param water_raster: mask of water cells (:type: raster)        :param s_pre_raster: soilwater content of the previous day (:type: raster)        :param rp_raster: reduction point (rp) (:type: raster)        :param rpwp_dif_raster: difference between reduction point (rp) and wilting point (wp) (:type: raster)        :param wp_raster: wilting point (wp) (:type: raster)        :param date: daily ID (Typ: integer)        :param parameter_safe: values of the variable combination (:type: tuple)        :return: AET (:type: raster)        """        aet_raster = Con(water_raster == 1, pet_raster,                         Con(s_pre_raster >= rp_raster, pet_raster,                             Con(rpwp_dif_raster == 0, 0, ((s_pre_raster - wp_raster) / rpwp_dif_raster) * pet_raster)))        aet_raster.save("AET_rp{}_c{}_{}.tif".format(parameter_safe[0], parameter_safe[1], date))        arcpy.AddMessage(time.strftime("%H:%M:%S: ") + "AET berechnet.")        return aet_raster    def get_precipitation(dataspace, date, idw_pow, rastercellsize, parameter_safe):        """        Interpolates the precipitation by Inverse Distance Weighting (IDW). The calculation is done by the "IDW" tool of the        "Spatial Analyst" extension of Arc GIS. The precipitation data is selected by a query table from the timeseries        table ("N_Zeitreihen") and the attribute table from the precipitation stations ("N_Messstationen").        :param dataspace: directory of the base data (:type: string)        :param date: daily ID (:type: integer)        :param idw_pow: IDW power (:type: float)        :param rastercellsize: raster cellsize (:type: float)        :param parameter_safe: values of the variable combination (:type: tuple)        :return: precipitation interpolation (:type: raster)        """        arcpy.MakeQueryTable_management(r'{}\N_Messstationen;'.format(dataspace) +                                        r'{}\N_Zeitreihen'.format(dataspace), "p_temp",                                        "USE_KEY_FIELDS", "N_Messstationen.Stationsnummer;N_Zeitreihen.TagesID",                                        "N_Messstationen.Stationsnummer;N_Messstationen.Stationsname; N_Messstationen.Shape\                                        ;N_Zeitreihen.Tagessumme_mm;N_Zeitreihen.TagesID", "N_Zeitreihen.Stationsnummer =\                                        N_Messstationen.Stationsnummer AND N_Zeitreihen.TagesID = {}".format(date))        idw = Idw("p_temp", "N_Zeitreihen.Tagessumme_mm", rastercellsize, idw_pow, RadiusFixed(20000.00000, 5), "")        idw.save("IDW_rp{}_c{}_{}.tif".format(parameter_safe[0], parameter_safe[1], date))        arcpy.Delete_management("p_temp")        arcpy.AddMessage(time.strftime("%H:%M:%S: ") + "Niederschlag interpoliert.")        return idw    def get_runoff(water_raster, lambda_param, wp_raster, p_raster, s_pre_raster, fc_raster, pet_raster, date,                   parameter_safe):        """        Calculates a raster dataset of the total runoff. The total runoff is the sum of the land runoff and the water        runoff. The first condition determines the amount of land runoff, the second condition determines the overflow and        the third condition determines the water runoff.        :param water_raster: mask of water cells (:type: raster)        :param lambda_param: Lambda value (:type: raster)        :param wp_raster: wilting point (wp) (:type: raster)        :param p_raster: output of the function "get_precipitation" (:type: raster)        :param s_pre_raster: soilwater content of the previous day (:type: raster)        :param fc_raster: field capacity (fc) (:type: raster)        :param pet_raster: output of the function "get_pet" (:type: raster)        :param date: daily ID (:type: integer)        :param parameter_safe: values of the variable combination (:type: tuple)        :return: total runoff (:type: raster)        """        r = Con(water_raster == 1, Con(p_raster > pet_raster, p_raster - pet_raster, p_raster), (                    lambda_param * ((s_pre_raster - wp_raster) ** 2) + Con(p_raster + s_pre_raster > fc_raster,                                                                           p_raster + s_pre_raster - fc_raster, 0)))        r.save("R_rp{}_c{}_{}.tif".format(parameter_safe[0], parameter_safe[1], date))        arcpy.AddMessage(time.strftime("%H:%M:%S: ") + "Gesamtabfluss je Rasterzelle berechnet.")        return r    def get_rsoil(water_raster, lambda_param, wp_raster, s_pre_raster, date, parameter_safe):        """        Calculates a raster dataset of the land runoff from soil (0 for water cells).        :param water_raster: mask of water cells (:type: raster)        :param lambda_param: Lambda value (:type: raster)        :param wp_raster: wilting point (wp) (:type: raster)        :param s_pre_raster: soilwater content of the previous day (:type: raster)        :param date: daily ID (:type: integer)        :param parameter_safe: values of the variable combination (:type: tuple)        :return: runoff from soil according to Glugla (1969) (:type: raster)        """        r = Con(water_raster == 1, 0, (lambda_param * ((s_pre_raster - wp_raster) ** 2)))        r.save("Rsoil_rp{}_c{}_{}.tif".format(parameter_safe[0], parameter_safe[1], date))        arcpy.AddMessage(time.strftime("%H:%M:%S: ") + "Soil runoff (Glugla 1969) je Rasterzelle berechnet.")        return r    def get_roverflow(water_raster, p_raster, s_pre_raster, fc_raster, date, parameter_safe):        """        Calculates a raster dataset of the overflow runoff, defined only for land areas whereas in water cells overflow of 0 is given.        :param water_raster: mask of water cells (:type: raster)        :param p_raster: output of the function "get_precipitation" (:type: raster)        :param s_pre_raster: soilwater content of the previous day (:type: raster)        :param fc_raster: field capacity (fc) (:type: raster)        :param date: daily ID (:type: integer)        :param parameter_safe: values of the variable combination (:type: tuple)        :return: overflow runoff (:type: raster)        """        r = Con(water_raster == 1, 0, Con(p_raster + s_pre_raster > fc_raster, p_raster + s_pre_raster - fc_raster, 0))        r.save("Roverflow_rp{}_c{}_{}.tif".format(parameter_safe[0], parameter_safe[1], date))        arcpy.AddMessage(time.strftime("%H:%M:%S: ") + "R overflow je Rasterzelle berechnet.")        return r    def get_soilwater(water_raster, s_pre_raster, p_raster, aet_raster, runoff_raster, date, parameter_safe):        """        Calculates a raster of the soilwater content based of the common equation of the water balance.        :param water_raster: mask of water cells (:type: raster)        :param s_pre_raster: soilwater content of the previous day (::type: raster)        :param p_raster: output of the function "get_precipitation" (::type: raster)        :param aet_raster: output of the function "get_aet" (::type: raster)        :param runoff_raster: output of the function "get_runoff" (::type: raster)        :param date: daily ID (::type: integer)        :param parameter_safe: values of the variable combination (::type: tuple)        :return: soilwater content (::type: raster)        """        soilwater = Con(water_raster == 0, s_pre_raster + p_raster - aet_raster - runoff_raster, )        soilwater = Con(soilwater < 0, 0, soilwater)        soilwater.save("S_rp{}_c{}_{}.tif".format(parameter_safe[0], parameter_safe[1], date))        arcpy.AddMessage(time.strftime("%H:%M:%S: ") + "Bodenwasserspeicher berechnet.")        return soilwater    def get_q_m3(runoff_raster, rastercellsize):        """        Calculates the streamflow of the basin in m^3 s^{-1} by converting the runoff-raster into an array.        :param runoff_raster: output of the function "get_runoff" (::type: raster)        :param rastercellsize: raster cellsize (::type: float)        :return: streamflow by basin in m^3 s^{-1} (::type: float)        """        array = arcpy.RasterToNumPyArray(runoff_raster, nodata_to_value=0)        r_sum = array.sum()        r_m3 = (r_sum * 0.001 * rastercellsize ** 2 / 24 / 60 / 60)        arcpy.AddMessage(time.strftime("%H:%M:%S: ") + "Q in m3 s-1 berechnet.")        return r_m3    def delete_raster(bool_pet, bool_aet, bool_p, bool_r, bool_s, bool_rs, bool_ro, parameter_safe, yesterday):        """        Deletes the raster datasets created by the functions above if selected from the previous day.        :param bool_pet: boolean to delete the PET-raster (::type: boolean)        :param bool_aet: boolean to delete the AET-raster (::type: boolean)        :param bool_p: boolean to delete the precipitation-raster (::type: boolean)        :param bool_r: boolean to delete the runoff-raster (::type: boolean)        :param bool_s: boolean to delete the soilwater-raster (::type: boolean)        :param bool_rs: boolean to delete the runoff from soil -raster (::type: boolean)        :param bool_ro: boolean to delete the overflow runoff-raster (::type: boolean)        :param parameter_safe: values of the variable combination (::type: tuple)        :param yesterday: previous daily ID (::type: integer)        :return:        """        for i in [("PET", bool_pet), ("AET", bool_aet), ("IDW", bool_p), ("R", bool_r), ("S", bool_s),                  ("Rsoil", bool_rs), ("Roverflow", bool_ro)]:            if not i[1]:                arcpy.Delete_management(                    "{}_rp{}_c{}_{}.tif".format(i[0], parameter_safe[0], parameter_safe[1], yesterday))    def delete_sum_raster(parameter_safe, yesterday):        """        Deletes the sum raster datasets created by the functions above if selected from the previous day.        :param parameter_safe: values of the variable combination (::type: tuple)        :param yesterday: previous daily ID (::type: integer)        :return:        """        for i in [("PET"), ("AET"), ("IDW"), ("R"), ("S"), ("Rsoil"), ("Roverflow")]:            arcpy.Delete_management(                "{}_sum_rp{}_c{}_{}_sumday.tif".format(i, parameter_safe[0], parameter_safe[1], yesterday))    def write_to_table(resultspace, tablename, result, date):        """        Writes the result value and the date into the current result table.        :param resultspace: working directory (::type: sting)        :param tablename: name of the result table (::type: string)        :param result: total streamflow by basin in m^3 s-1 (::type: float)        :param date: daily ID (::type: integer)        :return:        """        q_cursor = arcpy.da.InsertCursor(r'{0}\{1}'.format(resultspace, tablename), ["Datum", "Q"])        output_row = ["{0}.{1}.{2}".format(date[-2:], date[-4:-2], date[:4]), result]        q_cursor.insertRow(output_row)        del q_cursor    def rasterquotient_array(dividend, divisor):        """        Calculates the quotient of two rasters in a numpy array.        :param dividend: first raster object (:type: raster)        :param divisor: second raster object (:type: raster)        :return: numpy array of the quotient (:type: array)        """        quotient_array = arcpy.RasterToNumPyArray(dividend / divisor, nodata_to_value=0)        return quotient_array    def execute(self, parameters, messages):        """The source code of the tool."""        arcpy.CheckOutExtension("Spatial")        arcpy.AddMessage(time.strftime("%H:%M:%S: ") + "Systemmodule geladen.")        # Access the workspace parameter value        #data = parameters[0].valueAsText        #basin = parameters[1].valueAsText        #basinID = parameters[2].valueAsText        #s_init = arcpy.sa.ExtractByMask(parameters[3].valueAsText, basin)        #id_yesterday = start = int(parameters[4].valueAsText)        #end = int(parameters[5].valueAsText)        #rp_factor_min = float(parameters[6].valueAsText)        data = parameters[0].valueAsText if parameters[0].valueAsText else self.workspace_default        basin = parameters[1].valueAsText if parameters[1].valueAsText else self.basin_default        basinID = parameters[2].valueAsText if parameters[2].valueAsText else self.basinID_default        s_init = arcpy.sa.ExtractByMask(parameters[3].valueAsText, basin) if parameters[3].valueAsText else arcpy.sa.ExtractByMask(self.s_init_default, basin)        id_yesterday = start = parameters[4].valueAsText if parameters[4].valueAsText else self.start_default        end = parameters[5].valueAsText if parameters[5].valueAsText else self.end_default        rp_factor_min = float(parameters[6].valueAsText) if parameters[6].valueAsText else self.rp_factor_default        c_min = int(parameters[7].valueAsText) if parameters[7].valueAsText else self.c_min_default        idw_exponent = float(parameters[8].valueAsText) if parameters[8].valueAsText else self.idw_exponent_default        folder = parameters[9].valueAsText if parameters[9].valueAsText else self.workspace_default        name = parameters[10].valueAsText if parameters[10].valueAsText else self.name_default#        arcpy.AddMessage(f"workspace: {data}")#        arcpy.AddMessage(f"basin: {basin}")#        arcpy.AddMessage(f"basinID: {basinID}")#        arcpy.AddMessage(f"s_init: {s_init}")#        arcpy.AddMessage(f"start: {start}")#        arcpy.AddMessage(f"end: {end}")#        arcpy.AddMessage(f"rp: {rp_factor_min}")#        arcpy.AddMessage(f"c: {c_min}")#        arcpy.AddMessage(f"idw: {idw_exponent}")#        arcpy.AddMessage(f"folder: {folder}")#        arcpy.AddMessage(f"name: {name}")        """ set main settings and creating the working and scratch directory """        arcpy.env.overwriteOutput = True  # to overwrite results        arcpy.env.extent = s_init  # set the working extent        workpath = os.path.join(folder, name)        scratch = "Scratch"        scratchpath = os.path.join(folder,scratch)        #arcpy.AddMessage(f"workpath: {workpath}")        if not os.path.exists(workpath):  # if the working directory exists, it will be overwritten            try:                os.makedirs(workpath)                arcpy.AddMessage(f"Ausgabeordner erstellt: {workpath}")            except Exeption as e:                arcpyAddError(f"Ausgabeordner nicht erstellt: {str(e)}")        else:            arcpy.AddMessage("Ausgabeordner existiert bereits und wird neu aufgesetzt.")            arcpy.Delete_management(workpath)            os.makedirs(workpath)        if not os.path.exists(scratchpath):  # if the Scratch directory exists, it will be overwritten            try:                os.makedirs(scratchpath)                arcpy.AddMessage(f"Scratchordner erstellt: {scratchpath}")            except Exeption as e:                arcpyAddError(f"Scratchordner nicht erstellt: {str(e)}")        else:            arcpy.AddMessage("Scratchordner existiert bereits und wird neu aufgesetzt.")            arcpy.Delete_management(scratchpath)            os.makedirs(scratchpath)        arcpy.env.scratchWorkspace = scratchpath        arcpy.AddMessage(            time.strftime("%H:%M:%S: ") + f"Die Ergebnisdatenbank wurde im Verzeichnis {workpath} erstellt.")#            arcpy.AddMessage(f"not existing folder {folder}\{name}")       #     arcpy.Delete_management(r'{}\{}'.format(folder, name))       # arcpy.CreateFolder_management(folder, name)      #  workspace = arcpy.env.workspace = r'{}\{}'.format(folder, name)  # set the working directory       # arcpy.CreateFolder_management(folder, "Scratch")  # creates the scratch workspace for temporary dataset       # arcpy.env.scratchWorkspace = r'{}\Scratch'.format(folder)    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return